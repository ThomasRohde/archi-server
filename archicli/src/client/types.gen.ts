// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'http://127.0.0.1:8765' | (string & {});
};

export type HealthResponse = {
    /**
     * Server status
     */
    status?: 'ok' | 'stopping';
    version?: string;
    server?: {
        port?: number;
        host?: string;
        /**
         * Server uptime in milliseconds
         */
        uptime?: number;
    };
    operations?: QueueStats;
    model?: ModelInfo;
    memory?: MemoryInfo;
    timestamp?: string;
};

export type QueueStats = {
    queueSize?: number;
    queued?: number;
    processing?: number;
    completed?: number;
    error?: number;
    total?: number;
};

export type ModelInfo = {
    name?: string;
    id?: string;
    elements?: number;
    relationships?: number;
    views?: number;
    error?: string;
};

export type MemoryInfo = {
    totalMB?: number;
    freeMB?: number;
    usedMB?: number;
    maxMB?: number;
};

export type TestResponse = {
    success?: boolean;
    /**
     * Thread and model information
     */
    message?: string;
};

export type ShutdownResponse = {
    status?: 'stopping';
    message?: string;
    inFlightOperations?: number;
};

/**
 * Model diagnostics including orphan/ghost object detection
 */
export type DiagnosticsResponse = {
    timestamp?: string;
    model?: {
        name?: string;
        id?: string;
    };
    /**
     * Orphan objects found in EMF resource but missing from folder structure
     */
    orphans?: {
        orphanElements?: Array<{
            id?: string;
            name?: string;
            type?: string;
        }>;
        orphanRelationships?: Array<{
            id?: string;
            name?: string;
            type?: string;
            source?: string;
            target?: string;
        }>;
        totalOrphans?: number;
        /**
         * Error message if orphan detection failed
         */
        error?: string;
    };
    /**
     * Current snapshot summary (folder-based counts)
     */
    snapshot?: {
        elements?: number;
        relationships?: number;
        views?: number;
    };
};

export type QueryRequest = {
    /**
     * Maximum number of sample elements to return
     */
    limit?: number;
    /**
     * Optional maximum number of relationship samples to return
     */
    relationshipLimit?: number;
};

export type QueryResponse = {
    summary?: {
        elements?: number;
        relationships?: number;
        views?: number;
    };
    elements?: Array<ElementSummary>;
    /**
     * Present only when relationshipLimit is specified in the request
     */
    relationships?: Array<RelationshipSummary>;
};

export type ElementSummary = {
    id?: string;
    name?: string;
    type?: string;
    documentation?: string;
};

export type PlanRequest = {
    /**
     * Action to plan (e.g., "create-element")
     */
    action: string;
    /**
     * Element type for create actions
     */
    type?: string;
    /**
     * Element name for create actions
     */
    name?: string;
};

export type PlanResponse = {
    planId?: string;
    changes?: Array<ChangeOperation>;
    warnings?: Array<string>;
};

export type ApplyRequest = {
    changes: Array<ChangeOperation>;
};

export type ChangeOperation = ({
    op: 'createElement';
} & CreateElementOp) | ({
    op: 'createRelationship';
} & CreateRelationshipOp) | ({
    op: 'setProperty';
} & SetPropertyOp) | ({
    op: 'updateElement';
} & UpdateElementOp) | ({
    op: 'deleteElement';
} & DeleteElementOp) | ({
    op: 'deleteRelationship';
} & DeleteRelationshipOp) | ({
    op: 'updateRelationship';
} & UpdateRelationshipOp) | ({
    op: 'moveToFolder';
} & MoveToFolderOp) | ({
    op: 'createFolder';
} & CreateFolderOp) | ({
    op: 'addToView';
} & AddToViewOp) | ({
    op: 'addConnectionToView';
} & AddConnectionToViewOp) | ({
    op: 'nestInView';
} & NestInViewOp) | ({
    op: 'deleteConnectionFromView';
} & DeleteConnectionFromViewOp) | ({
    op: 'styleViewObject';
} & StyleViewObjectOp) | ({
    op: 'styleConnection';
} & StyleConnectionOp) | ({
    op: 'moveViewObject';
} & MoveViewObjectOp) | ({
    op: 'createNote';
} & CreateNoteOp) | ({
    op: 'createGroup';
} & CreateGroupOp) | ({
    op: 'createView';
} & CreateViewOp) | ({
    op: 'deleteView';
} & DeleteViewOp);

export type CreateElementOp = {
    op: 'createElement';
    type: ArchiMateElementType;
    name: string;
    /**
     * Temporary ID for referencing in subsequent operations
     */
    tempId?: string;
    documentation?: string;
    /**
     * Target folder path or ID
     */
    folder?: string;
};

export type CreateRelationshipOp = {
    op: 'createRelationship';
    type: ArchiMateRelationshipType;
    /**
     * Source element ID or tempId
     */
    sourceId: string;
    /**
     * Target element ID or tempId
     */
    targetId: string;
    name?: string;
    tempId?: string;
};

export type SetPropertyOp = {
    op: 'setProperty';
    /**
     * Element or relationship ID
     */
    id: string;
    /**
     * Property key
     */
    key: string;
    /**
     * Property value
     */
    value: string;
};

/**
 * Update an existing element's name, documentation, and/or properties.
 * At least one of `name`, `documentation`, or `properties` must be provided.
 *
 */
export type UpdateElementOp = {
    op: 'updateElement';
    /**
     * Element ID (real ID or tempId from prior createElement)
     */
    id: string;
    /**
     * New name for the element (optional)
     */
    name?: string;
    /**
     * New documentation text (optional)
     */
    documentation?: string;
    /**
     * Properties to set/update as key-value pairs (optional)
     */
    properties?: {
        [key: string]: string;
    };
};

export type DeleteElementOp = {
    op: 'deleteElement';
    /**
     * Element or relationship ID to delete
     */
    id: string;
    /**
     * If true (default), also removes all relationships where this element is
     * source or target, and all visual references across all views.
     * If false, only removes the element from its parent folder.
     *
     */
    cascade?: boolean;
};

export type AddToViewOp = {
    op: 'addToView';
    /**
     * Target view ID
     */
    viewId: string;
    /**
     * Element or relationship ID to add to view (real ID or tempId)
     */
    elementId: string;
    /**
     * Temporary ID for referencing the created visual object in subsequent operations
     */
    tempId?: string;
    /**
     * Visual object ID of the parent container to nest this element inside.
     * Can be a visual object ID or tempId from a prior addToView/createGroup operation.
     * Coordinates (x, y) become relative to the parent container's bounds.
     * If omitted, the element is added to the view root.
     *
     */
    parentVisualId?: string;
    /**
     * X coordinate (relative to parent container or view root, default 100)
     */
    x?: number;
    /**
     * Y coordinate (relative to parent container or view root, default 100)
     */
    y?: number;
    /**
     * Width in pixels (-1 for default)
     */
    width?: number;
    /**
     * Height in pixels (-1 for default)
     */
    height?: number;
    /**
     * If true, auto-nest inside surrounding visual objects
     */
    autoNest?: boolean;
};

/**
 * Add a relationship as a visual connection in a view.
 * Source and target visuals can be specified explicitly via sourceVisualId/targetVisualId,
 * or resolved automatically when autoResolveVisuals is true. Auto-resolution finds visual
 * objects by matching the relationship's source/target element IDs against visuals in the
 * view (same-batch or already committed).
 *
 */
export type AddConnectionToViewOp = {
    op: 'addConnectionToView';
    /**
     * Target view ID
     */
    viewId: string;
    /**
     * Relationship ID to visualize (real ID or tempId)
     */
    relationshipId: string;
    /**
     * Source visual object ID (from addToView result or existing visual). Optional when autoResolveVisuals is true.
     */
    sourceVisualId?: string;
    /**
     * Target visual object ID (from addToView result or existing visual). Optional when autoResolveVisuals is true.
     */
    targetVisualId?: string;
    /**
     * When true, automatically resolve source and target visual objects by matching the
     * relationship's source/target elements against visual objects in the view. This
     * eliminates the need to provide sourceVisualId and targetVisualId. The server checks
     * same-batch operations first (via tempId index), then falls back to committed view
     * children. The result includes autoResolved: true when resolution succeeds.
     *
     */
    autoResolveVisuals?: boolean;
};

/**
 * Move an existing visual object to be a child of another visual object in the same view.
 * This is the equivalent of jArchi's parent.add(object, x, y) method.
 * The x, y position is relative to the target parent object's bounds.
 * Use this to create proper visual nesting for compound elements (e.g., an Application Component
 * containing child Application Components via composition relationships).
 *
 */
export type NestInViewOp = {
    op: 'nestInView';
    /**
     * View ID containing both visual objects
     */
    viewId: string;
    /**
     * Visual object ID (or tempId) to move into the parent
     */
    visualId: string;
    /**
     * Visual object ID (or tempId) of the target parent container
     */
    parentVisualId: string;
    /**
     * X position relative to parent container (default 10)
     */
    x?: number;
    /**
     * Y position relative to parent container (default 10)
     */
    y?: number;
};

/**
 * Delete a visual connection from a view.
 * Use this to remove orphaned or incorrectly-created connections.
 * The underlying model relationship is NOT deleted.
 *
 */
export type DeleteConnectionFromViewOp = {
    op: 'deleteConnectionFromView';
    /**
     * View ID containing the connection
     */
    viewId: string;
    /**
     * Connection ID to delete (from addConnectionToView result or view details)
     */
    connectionId: string;
};

export type DeleteRelationshipOp = {
    op: 'deleteRelationship';
    /**
     * Relationship ID to delete
     */
    id: string;
};

export type UpdateRelationshipOp = {
    op: 'updateRelationship';
    /**
     * Relationship ID
     */
    id: string;
    /**
     * New name for the relationship (optional)
     */
    name?: string;
    /**
     * New documentation text (optional)
     */
    documentation?: string;
    /**
     * Properties to set/update as key-value pairs (optional)
     */
    properties?: {
        [key: string]: string;
    };
};

export type MoveToFolderOp = {
    op: 'moveToFolder';
    /**
     * Element, relationship, or view ID to move
     */
    id: string;
    /**
     * Target folder ID, or a createFolder tempId from an earlier operation in the same batch
     */
    folderId: string;
};

export type CreateFolderOp = unknown & {
    op: 'createFolder';
    /**
     * Folder name
     */
    name: string;
    /**
     * Parent folder ID
     */
    parentId?: string;
    /**
     * Parent top-level folder type token (for example BUSINESS, APPLICATION, TECHNOLOGY, VIEWS)
     */
    parentType?: string;
    /**
     * Parent folder display name (for example Business, Application, Views)
     */
    parentFolder?: string;
    /**
     * Optional folder documentation
     */
    documentation?: string;
    /**
     * Temporary ID for referencing in subsequent operations
     */
    tempId?: string;
};

/**
 * Apply visual styling to a view object (element, note, or group)
 */
export type StyleViewObjectOp = {
    op: 'styleViewObject';
    /**
     * Visual object ID in a view
     */
    viewObjectId: string;
    /**
     * Fill color in hex format (e.g., "#FF5733")
     */
    fillColor?: string;
    /**
     * Line/border color in hex format
     */
    lineColor?: string;
    /**
     * Font color in hex format
     */
    fontColor?: string;
    /**
     * Fill opacity (0=transparent, 255=opaque)
     */
    opacity?: number;
    /**
     * Border line width in pixels
     */
    lineWidth?: number;
    /**
     * Text alignment (0=left, 1=center, 2=right)
     */
    textAlignment?: 0 | 1 | 2;
    /**
     * Text position (0=top, 1=middle, 2=bottom)
     */
    textPosition?: 0 | 1 | 2;
};

/**
 * Apply visual styling to a connection in a view
 */
export type StyleConnectionOp = {
    op: 'styleConnection';
    /**
     * Connection ID in a view
     */
    connectionId: string;
    /**
     * Line color in hex format
     */
    lineColor?: string;
    /**
     * Font color in hex format
     */
    fontColor?: string;
    /**
     * Line width in pixels
     */
    lineWidth?: number;
    /**
     * Label position (0=source, 1=middle, 2=target)
     */
    textPosition?: 0 | 1 | 2;
};

/**
 * Move or resize a visual object in a view
 */
export type MoveViewObjectOp = {
    op: 'moveViewObject';
    /**
     * Visual object ID
     */
    viewObjectId: string;
    /**
     * New X coordinate
     */
    x?: number;
    /**
     * New Y coordinate
     */
    y?: number;
    /**
     * New width
     */
    width?: number;
    /**
     * New height
     */
    height?: number;
};

/**
 * Create a note (text annotation) in a view
 */
export type CreateNoteOp = {
    op: 'createNote';
    /**
     * Target view ID
     */
    viewId: string;
    /**
     * Note text content
     */
    content: string;
    /**
     * Temporary ID for referencing in subsequent operations
     */
    tempId?: string;
    /**
     * X coordinate (default 100)
     */
    x?: number;
    /**
     * Y coordinate (default 100)
     */
    y?: number;
    /**
     * Width (default 200)
     */
    width?: number;
    /**
     * Height (default 100)
     */
    height?: number;
};

/**
 * Create a visual group in a view
 */
export type CreateGroupOp = {
    op: 'createGroup';
    /**
     * Target view ID
     */
    viewId: string;
    /**
     * Group name/label
     */
    name: string;
    /**
     * Temporary ID for referencing in subsequent operations
     */
    tempId?: string;
    /**
     * X coordinate (default 100)
     */
    x?: number;
    /**
     * Y coordinate (default 100)
     */
    y?: number;
    /**
     * Width (default 400)
     */
    width?: number;
    /**
     * Height (default 300)
     */
    height?: number;
};

/**
 * Create a new view in the model
 */
export type CreateViewOp = {
    op: 'createView';
    /**
     * View name
     */
    name: string;
    /**
     * Temporary ID for referencing in subsequent operations
     */
    tempId?: string;
    /**
     * View documentation
     */
    documentation?: string;
    /**
     * ArchiMate viewpoint ID (for example application_cooperation)
     */
    viewpoint?: string;
};

/**
 * Delete a view by ID
 */
export type DeleteViewOp = {
    op: 'deleteView';
    /**
     * View ID to delete
     */
    viewId: string;
};

export type ApplyResponse = {
    operationId?: string;
    status?: 'queued';
    message?: string;
    digest?: OperationDigest;
    tempIdMap?: {
        [key: string]: string;
    };
    tempIdMappings?: Array<TempIdMapping>;
};

export type OperationStatusResponse = {
    operationId?: string;
    status?: 'queued' | 'processing' | 'complete' | 'error';
    /**
     * Array of operation results (when status is complete)
     */
    result?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Total number of result rows available before paging
     */
    totalResultCount?: number;
    /**
     * Current cursor offset for paged results
     */
    cursor?: string;
    /**
     * Page size used for result paging
     */
    pageSize?: number;
    /**
     * True when additional paged rows are available
     */
    hasMore?: boolean;
    /**
     * Cursor token for the next page
     */
    nextCursor?: string;
    /**
     * True when response is compact metadata without result rows
     */
    summaryOnly?: boolean;
    /**
     * Error message (when status is error)
     */
    error?: string;
    /**
     * Structured context for failed operations (when status is error)
     */
    errorDetails?: {
        message?: string;
        /**
         * Zero-based index in /changes array
         */
        opIndex?: number;
        /**
         * One-based operation number for human-readable output
         */
        opNumber?: number;
        /**
         * JSON pointer-like location (e.g. /changes/2)
         */
        path?: string;
        /**
         * Operation type (e.g. addToView)
         */
        op?: string;
        /**
         * Field involved in the failure context
         */
        field?: string;
        /**
         * Unresolved id/tempId value when detected
         */
        reference?: string;
        /**
         * Short remediation hint
         */
        hint?: string;
        /**
         * Original change payload for the failing operation (best effort)
         */
        change?: {
            [key: string]: unknown;
        };
    };
    message?: string;
    createdAt?: string;
    startedAt?: string;
    completedAt?: string;
    /**
     * Duration in milliseconds (included for both complete and error status)
     */
    durationMs?: number;
    digest?: OperationDigest;
    tempIdMap?: {
        [key: string]: string;
    };
    tempIdMappings?: Array<TempIdMapping>;
    timeline?: Array<OperationTimelineEvent>;
    retryHints?: Array<{
        [key: string]: unknown;
    }>;
};

export type OperationSummary = {
    operationId?: string;
    status?: 'queued' | 'processing' | 'complete' | 'error';
    createdAt?: string;
    startedAt?: string;
    completedAt?: string;
    durationMs?: number;
    changeCount?: number;
    error?: string;
    digest?: OperationDigest;
    tempIdMap?: {
        [key: string]: string;
    };
    tempIdMappings?: Array<TempIdMapping>;
    timeline?: Array<OperationTimelineEvent>;
    retryHints?: Array<{
        [key: string]: unknown;
    }>;
};

export type OperationListResponse = {
    operations?: Array<OperationSummary>;
    total?: number;
    limit?: number;
    status?: string;
    cursor?: string;
    hasMore?: boolean;
    nextCursor?: string;
    summaryOnly?: boolean;
};

export type TempIdMapping = {
    tempId?: string;
    resolvedId?: string;
    mappingType?: 'concept' | 'visual' | 'connection' | 'view';
    op?: string;
    resultIndex?: number;
};

export type OperationTimelineEvent = {
    status?: 'queued' | 'processing' | 'complete' | 'failed';
    timestamp?: string;
    chunkIndex?: number;
    chunkCount?: number;
    operationCount?: number;
    resultCount?: number;
    error?: string;
    opIndex?: number;
    op?: string;
};

export type OperationDigest = {
    totals?: {
        requested?: number;
        results?: number;
        executed?: number;
        skipped?: number;
    };
    requestedByType?: {
        [key: string]: number;
    };
    executedByType?: {
        [key: string]: number;
    };
    skipsByReason?: {
        [key: string]: number;
    };
    integrityFlags?: {
        [key: string]: boolean;
    };
};

export type ErrorResponse = {
    error?: {
        code?: string;
        message?: string;
    };
};

/**
 * Search criteria for finding elements/relationships
 */
export type SearchRequest = {
    /**
     * Filter by element/relationship type (e.g., "application-component")
     */
    type?: string;
    /**
     * Regex pattern to match against names
     */
    namePattern?: string;
    /**
     * Property key to filter by
     */
    propertyKey?: string;
    /**
     * Property value to match (used with propertyKey)
     */
    propertyValue?: string;
    /**
     * Include relationships in result set (default true)
     */
    includeRelationships?: boolean;
    /**
     * Maximum number of results to return
     */
    limit?: number;
};

export type SearchResponse = {
    results?: Array<SearchResult>;
    /**
     * Total number of matching items
     */
    total?: number;
    criteria?: {
        type?: string;
        namePattern?: string;
        propertyKey?: string;
        propertyValue?: string;
        includeRelationships?: boolean;
        limit?: number;
    };
};

export type SearchResult = {
    id?: string;
    name?: string;
    type?: string;
    documentation?: string;
};

export type RelationshipSummary = {
    id?: string;
    name?: string;
    type?: string;
    source?: string;
    target?: string;
    sourceId?: string;
    targetId?: string;
    /**
     * Property key that matched the search filter
     */
    matchedPropertyKey?: string;
    /**
     * Property value that matched the search filter
     */
    matchedPropertyValue?: string;
    /**
     * Whether this is an element or relationship
     */
    kind?: 'element' | 'relationship';
};

export type ElementDetailResponse = {
    id?: string;
    name?: string;
    type?: string;
    documentation?: string;
    /**
     * Custom properties as key-value pairs
     */
    properties?: {
        [key: string]: string;
    };
    relationships?: {
        incoming?: Array<RelationshipInfo>;
        outgoing?: Array<RelationshipInfo>;
    };
    /**
     * Views containing this element
     */
    views?: Array<ViewReference>;
};

export type RelationshipInfo = {
    id?: string;
    type?: string;
    name?: string;
    /**
     * ID of the element at the other end
     */
    otherEndId?: string;
    otherEndName?: string;
    otherEndType?: string;
};

export type ViewReference = {
    id?: string;
    name?: string;
};

export type SaveResponse = {
    success?: boolean;
    message?: string;
    /**
     * Name of the saved model
     */
    modelName?: string;
    /**
     * ID of the saved model
     */
    modelId?: string;
    /**
     * File path where the model was saved
     */
    path?: string;
    /**
     * Time taken to save in milliseconds
     */
    durationMs?: number;
    /**
     * Present and true when the server auto-generated the save path
     * because the model was never saved and no path was provided
     *
     */
    autoGeneratedPath?: boolean;
};

export type StatsResponse = {
    summary?: {
        totalElements?: number;
        totalRelationships?: number;
        totalViews?: number;
        /**
         * Number of distinct element types in model
         */
        elementTypes?: number;
        /**
         * Number of distinct relationship types in model
         */
        relationshipTypes?: number;
        /**
         * Number of distinct view types in model
         */
        viewTypes?: number;
    };
    /**
     * Element counts grouped by ArchiMate type
     */
    elements?: {
        [key: string]: number;
    };
    /**
     * Relationship counts grouped by ArchiMate type
     */
    relationships?: {
        [key: string]: number;
    };
    /**
     * View counts grouped by type
     */
    views?: {
        [key: string]: number;
    };
};

export type FolderListResponse = {
    folders?: Array<FolderInfo>;
};

export type FolderInfo = {
    id?: string;
    name?: string;
    /**
     * Folder type (root folder category or user-created)
     */
    type?: 'business' | 'application' | 'technology' | 'motivation' | 'strategy' | 'implementation_migration' | 'other' | 'relations' | 'diagrams';
    /**
     * Full path from root (e.g., "Business/Processes/Core")
     */
    path?: string;
    /**
     * Nested subfolders
     */
    children?: Array<FolderInfo>;
};

export type LayoutRequest = {
    /**
     * Layout algorithm to apply
     */
    algorithm?: 'dagre' | 'sugiyama';
    /**
     * Graph direction (TB=top-bottom, LR=left-right, etc.)
     */
    rankdir?: 'TB' | 'BT' | 'LR' | 'RL';
    /**
     * Vertical separation between ranks in pixels
     */
    ranksep?: number;
    /**
     * Horizontal separation between nodes in pixels
     */
    nodesep?: number;
    /**
     * Pixels between edges
     */
    edgesep?: number;
    /**
     * Left/right margin in pixels
     */
    marginx?: number;
    /**
     * Top/bottom margin in pixels
     */
    marginy?: number;
};

export type LayoutResponse = {
    success?: boolean;
    viewId?: string;
    algorithm?: string;
    /**
     * Layout options that were applied
     */
    options?: {
        [key: string]: unknown;
    };
    /**
     * Number of nodes repositioned
     */
    nodesPositioned?: number;
    /**
     * Layout duration in milliseconds
     */
    durationMs?: number;
};

export type DuplicateViewResponse = {
    success?: boolean;
    originalViewId?: string;
    newViewId?: string;
    newViewName?: string;
    durationMs?: number;
};

export type SetRouterResponse = {
    success?: boolean;
    viewId?: string;
    viewName?: string;
    router?: 'bendpoint' | 'manhattan';
    durationMs?: number;
};

/**
 * Result of view connection integrity validation
 */
export type ValidateViewResponse = {
    /**
     * True if all checks passed
     */
    valid?: boolean;
    viewId?: string;
    viewName?: string;
    checks?: Array<ValidationCheck>;
};

export type ValidationCheck = {
    /**
     * Check name (e.g., "orphaned_connections", "direction_mismatches")
     */
    name?: string;
    description?: string;
    passed?: boolean;
    violations?: Array<ValidationViolation>;
};

export type ValidationViolation = {
    connectionId?: string;
    connectionName?: string;
    /**
     * Description of the problem
     */
    issue?: string;
    /**
     * Suggested fix for the violation
     */
    fix?: string;
    relationshipId?: string;
    visualSourceElement?: string;
    visualTargetElement?: string;
    relationshipSourceElement?: string;
    relationshipTargetElement?: string;
};

export type ScriptRunRequest = {
    /**
     * JavaScript code to execute
     */
    code: string;
};

export type ScriptRunResponse = {
    success?: boolean;
    output?: Array<ConsoleOutput>;
    /**
     * File paths created/modified by the script
     */
    files?: Array<string>;
    /**
     * Return value if script sets __scriptResult.value
     */
    result?: unknown;
    error?: string;
    durationMs?: number;
};

export type ConsoleOutput = {
    level?: 'log' | 'print' | 'println' | 'error';
    message?: string;
};

/**
 * Valid ArchiMate element types
 */
export type ArchiMateElementType = 'resource' | 'capability' | 'value-stream' | 'course-of-action' | 'business-actor' | 'business-role' | 'business-collaboration' | 'business-interface' | 'business-process' | 'business-function' | 'business-interaction' | 'business-event' | 'business-service' | 'business-object' | 'contract' | 'representation' | 'product' | 'application-component' | 'application-collaboration' | 'application-interface' | 'application-function' | 'application-interaction' | 'application-process' | 'application-event' | 'application-service' | 'data-object' | 'node' | 'device' | 'system-software' | 'technology-collaboration' | 'technology-interface' | 'path' | 'communication-network' | 'technology-function' | 'technology-process' | 'technology-interaction' | 'technology-event' | 'technology-service' | 'artifact' | 'equipment' | 'facility' | 'distribution-network' | 'material' | 'stakeholder' | 'driver' | 'assessment' | 'goal' | 'outcome' | 'principle' | 'requirement' | 'constraint' | 'meaning' | 'value' | 'work-package' | 'deliverable' | 'implementation-event' | 'plateau' | 'gap' | 'location' | 'grouping' | 'junction';

/**
 * Valid ArchiMate relationship types
 */
export type ArchiMateRelationshipType = 'composition-relationship' | 'aggregation-relationship' | 'assignment-relationship' | 'realization-relationship' | 'serving-relationship' | 'access-relationship' | 'influence-relationship' | 'triggering-relationship' | 'flow-relationship' | 'specialization-relationship' | 'association-relationship';

export type ViewListResponse = {
    views?: Array<ViewSummary>;
    total?: number;
};

export type ViewSummary = {
    /**
     * Unique view ID
     */
    id?: string;
    /**
     * View name
     */
    name?: string;
    /**
     * View type
     */
    type?: 'archimate-diagram-model' | 'sketch-model' | 'canvas-model';
    /**
     * ArchiMate viewpoint (e.g., "application_cooperation")
     */
    viewpoint?: string;
    /**
     * Number of visual objects in view
     */
    objectCount?: number;
    /**
     * Number of connections in view
     */
    connectionCount?: number;
};

export type CreateViewRequest = {
    /**
     * Name for the new view
     */
    name: string;
    /**
     * ArchiMate viewpoint ID or label (optional, e.g., "application_cooperation" or "Application Cooperation")
     */
    viewpoint?: string;
    /**
     * Target folder path or ID
     */
    folder?: string;
    /**
     * View documentation
     */
    documentation?: string;
    /**
     * Allow creating a view even if one with this name already exists.
     * When false (default), returns 409 Conflict if name exists.
     *
     */
    allowDuplicate?: boolean;
};

export type CreateViewResponse = {
    success?: boolean;
    /**
     * ID of the created view
     */
    viewId?: string;
    /**
     * Name of the created view
     */
    viewName?: string;
    /**
     * Type of the created view
     */
    viewType?: string;
    /**
     * Viewpoint ID if specified
     */
    viewpoint?: string;
    /**
     * Documentation if specified
     */
    documentation?: string;
    /**
     * Creation duration in milliseconds
     */
    durationMs?: number;
};

export type ViewDetailResponse = {
    id?: string;
    name?: string;
    type?: 'archimate-diagram-model' | 'sketch-model' | 'canvas-model';
    documentation?: string;
    viewpoint?: string;
    /**
     * Connection routing style
     */
    connectionRouter?: 'bendpoint' | 'manhattan';
    elements?: Array<ViewElement>;
    connections?: Array<ViewConnection>;
};

export type ViewElement = {
    /**
     * Visual object ID (diagram object)
     */
    id?: string;
    /**
     * Visual element type
     */
    type?: string;
    name?: string;
    x?: number;
    y?: number;
    width?: number;
    height?: number;
    /**
     * Visual object ID of the parent container, if this element is nested inside
     * another visual object (e.g., a group or compound element). Null/absent for
     * top-level elements. Coordinates (x, y) are relative to the parent when present.
     *
     */
    parentId?: string;
    /**
     * Underlying ArchiMate concept ID
     */
    conceptId?: string;
    /**
     * Underlying ArchiMate concept type
     */
    conceptType?: string;
};

export type ViewConnection = {
    /**
     * Visual connection ID
     */
    id?: string;
    /**
     * Connection type
     */
    type?: string;
    name?: string;
    /**
     * Source visual object ID
     */
    sourceId?: string;
    /**
     * Target visual object ID
     */
    targetId?: string;
    /**
     * Underlying ArchiMate relationship ID
     */
    conceptId?: string;
    /**
     * Underlying ArchiMate relationship type
     */
    conceptType?: string;
};

export type ExportViewRequest = {
    /**
     * Export format (PNG or JPEG)
     */
    format?: 'PNG' | 'JPG' | 'JPEG';
    /**
     * Absolute or relative file path for output. Relative paths resolve from server process working directory.
     * If omitted, a temporary file is created.
     * Parent directories are created automatically.
     *
     */
    outputPath?: string;
    /**
     * Image scale factor
     */
    scale?: number;
    /**
     * Margin in pixels
     */
    margin?: number;
};

export type ExportViewResponse = {
    success?: boolean;
    viewId?: string;
    viewName?: string;
    format?: 'PNG' | 'JPG';
    /**
     * Absolute path to exported file
     */
    filePath?: string;
    /**
     * File size in bytes
     */
    fileSizeBytes?: number;
    /**
     * Export duration in milliseconds
     */
    durationMs?: number;
};

export type GetHealthData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/health';
};

export type GetHealthResponses = {
    /**
     * Server health information
     */
    200: HealthResponse;
};

export type GetHealthResponse = GetHealthResponses[keyof GetHealthResponses];

export type GetTestData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/test';
};

export type GetTestResponses = {
    /**
     * Test result
     */
    200: TestResponse;
};

export type GetTestResponse = GetTestResponses[keyof GetTestResponses];

export type PostShutdownData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/shutdown';
};

export type PostShutdownResponses = {
    /**
     * Shutdown initiated
     */
    200: ShutdownResponse;
};

export type PostShutdownResponse = PostShutdownResponses[keyof PostShutdownResponses];

export type GetModelDiagnosticsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/model/diagnostics';
};

export type GetModelDiagnosticsErrors = {
    /**
     * No model loaded
     */
    400: ErrorResponse;
};

export type GetModelDiagnosticsError = GetModelDiagnosticsErrors[keyof GetModelDiagnosticsErrors];

export type GetModelDiagnosticsResponses = {
    /**
     * Diagnostics result
     */
    200: DiagnosticsResponse;
};

export type GetModelDiagnosticsResponse = GetModelDiagnosticsResponses[keyof GetModelDiagnosticsResponses];

export type PostModelQueryData = {
    body?: QueryRequest;
    path?: never;
    query?: never;
    url: '/model/query';
};

export type PostModelQueryErrors = {
    /**
     * Query failed
     */
    500: ErrorResponse;
};

export type PostModelQueryError = PostModelQueryErrors[keyof PostModelQueryErrors];

export type PostModelQueryResponses = {
    /**
     * Model query result
     */
    200: QueryResponse;
};

export type PostModelQueryResponse = PostModelQueryResponses[keyof PostModelQueryResponses];

export type PostModelPlanData = {
    body: PlanRequest;
    path?: never;
    query?: never;
    url: '/model/plan';
};

export type PostModelPlanErrors = {
    /**
     * Bad request
     */
    400: ErrorResponse;
};

export type PostModelPlanError = PostModelPlanErrors[keyof PostModelPlanErrors];

export type PostModelPlanResponses = {
    /**
     * Change plan generated
     */
    200: PlanResponse;
};

export type PostModelPlanResponse = PostModelPlanResponses[keyof PostModelPlanResponses];

export type PostModelSearchData = {
    body?: SearchRequest;
    path?: never;
    query?: never;
    url: '/model/search';
};

export type PostModelSearchErrors = {
    /**
     * Search failed
     */
    500: ErrorResponse;
};

export type PostModelSearchError = PostModelSearchErrors[keyof PostModelSearchErrors];

export type PostModelSearchResponses = {
    /**
     * Search results
     */
    200: SearchResponse;
};

export type PostModelSearchResponse = PostModelSearchResponses[keyof PostModelSearchResponses];

export type GetElementByIdData = {
    body?: never;
    path: {
        /**
         * Element ID
         */
        elementId: string;
    };
    query?: never;
    url: '/model/element/{elementId}';
};

export type GetElementByIdErrors = {
    /**
     * Element not found
     */
    404: ErrorResponse;
    /**
     * Internal error
     */
    500: ErrorResponse;
};

export type GetElementByIdError = GetElementByIdErrors[keyof GetElementByIdErrors];

export type GetElementByIdResponses = {
    /**
     * Element details
     */
    200: ElementDetailResponse;
};

export type GetElementByIdResponse = GetElementByIdResponses[keyof GetElementByIdResponses];

export type PostModelSaveData = {
    body?: {
        /**
         * Absolute file path to save the model to (e.g. "/path/to/model.archimate").
         * Optional - if omitted for unsaved models, path is auto-generated.
         * The .archimate extension is appended automatically if missing.
         *
         */
        path?: string;
    };
    path?: never;
    query?: never;
    url: '/model/save';
};

export type PostModelSaveErrors = {
    /**
     * Save failed
     */
    500: ErrorResponse;
};

export type PostModelSaveError = PostModelSaveErrors[keyof PostModelSaveErrors];

export type PostModelSaveResponses = {
    /**
     * Model saved successfully
     */
    200: SaveResponse;
};

export type PostModelSaveResponse = PostModelSaveResponses[keyof PostModelSaveResponses];

export type GetModelStatsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/model/stats';
};

export type GetModelStatsErrors = {
    /**
     * Internal error
     */
    500: ErrorResponse;
};

export type GetModelStatsError = GetModelStatsErrors[keyof GetModelStatsErrors];

export type GetModelStatsResponses = {
    /**
     * Model statistics
     */
    200: StatsResponse;
};

export type GetModelStatsResponse = GetModelStatsResponses[keyof GetModelStatsResponses];

export type GetFoldersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/folders';
};

export type GetFoldersErrors = {
    /**
     * Internal error
     */
    500: ErrorResponse;
};

export type GetFoldersError = GetFoldersErrors[keyof GetFoldersErrors];

export type GetFoldersResponses = {
    /**
     * Folder list
     */
    200: FolderListResponse;
};

export type GetFoldersResponse = GetFoldersResponses[keyof GetFoldersResponses];

export type PostModelApplyData = {
    body: ApplyRequest;
    path?: never;
    query?: never;
    url: '/model/apply';
};

export type PostModelApplyErrors = {
    /**
     * Validation error
     */
    400: ErrorResponse;
};

export type PostModelApplyError = PostModelApplyErrors[keyof PostModelApplyErrors];

export type PostModelApplyResponses = {
    /**
     * Operation queued
     */
    200: ApplyResponse;
};

export type PostModelApplyResponse = PostModelApplyResponses[keyof PostModelApplyResponses];

export type GetOpsStatusData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Operation ID returned from `/model/apply`
         */
        opId: string;
        /**
         * Return compact status metadata without result payload rows
         */
        summaryOnly?: boolean;
        /**
         * Zero-based cursor offset for paged result rows
         */
        cursor?: string;
        /**
         * Number of result rows per page (1-1000, default 200)
         */
        pageSize?: number;
    };
    url: '/ops/status';
};

export type GetOpsStatusErrors = {
    /**
     * Missing opId parameter
     */
    400: ErrorResponse;
    /**
     * Operation not found
     */
    404: ErrorResponse;
};

export type GetOpsStatusError = GetOpsStatusErrors[keyof GetOpsStatusErrors];

export type GetOpsStatusResponses = {
    /**
     * Operation status
     */
    200: OperationStatusResponse;
};

export type GetOpsStatusResponse = GetOpsStatusResponses[keyof GetOpsStatusResponses];

export type GetOpsListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Maximum number of operations to return (1-200, default 20)
         */
        limit?: number;
        /**
         * Optional status filter
         */
        status?: 'queued' | 'processing' | 'complete' | 'error';
        /**
         * Zero-based cursor offset for paged operation summaries
         */
        cursor?: string;
        /**
         * Return compact operation summaries only
         */
        summaryOnly?: boolean;
    };
    url: '/ops/list';
};

export type GetOpsListErrors = {
    /**
     * Invalid query parameter
     */
    400: ErrorResponse;
};

export type GetOpsListError = GetOpsListErrors[keyof GetOpsListErrors];

export type GetOpsListResponses = {
    /**
     * Operation list
     */
    200: OperationListResponse;
};

export type GetOpsListResponse = GetOpsListResponses[keyof GetOpsListResponses];

export type PostScriptsRunData = {
    body: ScriptRunRequest;
    path?: never;
    query?: never;
    url: '/scripts/run';
};

export type PostScriptsRunErrors = {
    /**
     * Validation error
     */
    400: ErrorResponse;
    /**
     * Script execution error
     */
    500: ErrorResponse;
};

export type PostScriptsRunError = PostScriptsRunErrors[keyof PostScriptsRunErrors];

export type PostScriptsRunResponses = {
    /**
     * Script execution result
     */
    200: ScriptRunResponse;
};

export type PostScriptsRunResponse = PostScriptsRunResponses[keyof PostScriptsRunResponses];

export type GetViewsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/views';
};

export type GetViewsErrors = {
    /**
     * Internal error
     */
    500: ErrorResponse;
};

export type GetViewsError = GetViewsErrors[keyof GetViewsErrors];

export type GetViewsResponses = {
    /**
     * List of views
     */
    200: ViewListResponse;
};

export type GetViewsResponse = GetViewsResponses[keyof GetViewsResponses];

export type PostViewsData = {
    body: CreateViewRequest;
    path?: never;
    query?: never;
    url: '/views';
};

export type PostViewsErrors = {
    /**
     * Validation error
     */
    400: ErrorResponse;
    /**
     * View name already exists
     */
    409: {
        error?: {
            code?: 'ViewNameExists';
            message?: string;
            /**
             * ID of the existing view with this name
             */
            existingViewId?: string;
        };
    };
    /**
     * Internal error
     */
    500: ErrorResponse;
};

export type PostViewsError = PostViewsErrors[keyof PostViewsErrors];

export type PostViewsResponses = {
    /**
     * View created successfully
     */
    200: CreateViewResponse;
};

export type PostViewsResponse = PostViewsResponses[keyof PostViewsResponses];

export type DeleteViewData = {
    body?: never;
    path: {
        /**
         * View ID to delete
         */
        viewId: string;
    };
    query?: never;
    url: '/views/{viewId}';
};

export type DeleteViewErrors = {
    /**
     * View not found
     */
    404: ErrorResponse;
    /**
     * Delete failed
     */
    500: ErrorResponse;
};

export type DeleteViewError = DeleteViewErrors[keyof DeleteViewErrors];

export type DeleteViewResponses = {
    /**
     * View deleted
     */
    200: {
        success?: boolean;
        viewId?: string;
        viewName?: string;
    };
};

export type DeleteViewResponse = DeleteViewResponses[keyof DeleteViewResponses];

export type GetViewByIdData = {
    body?: never;
    path: {
        /**
         * View ID
         */
        viewId: string;
    };
    query?: never;
    url: '/views/{viewId}';
};

export type GetViewByIdErrors = {
    /**
     * Invalid request
     */
    400: ErrorResponse;
    /**
     * View not found
     */
    404: ErrorResponse;
    /**
     * Internal error
     */
    500: ErrorResponse;
};

export type GetViewByIdError = GetViewByIdErrors[keyof GetViewByIdErrors];

export type GetViewByIdResponses = {
    /**
     * View details
     */
    200: ViewDetailResponse;
};

export type GetViewByIdResponse = GetViewByIdResponses[keyof GetViewByIdResponses];

export type PostViewExportData = {
    body?: ExportViewRequest;
    path: {
        /**
         * View ID to export
         */
        viewId: string;
    };
    query?: never;
    url: '/views/{viewId}/export';
};

export type PostViewExportErrors = {
    /**
     * Invalid format or request
     */
    400: ErrorResponse;
    /**
     * View not found
     */
    404: ErrorResponse;
    /**
     * Export failed
     */
    500: ErrorResponse;
};

export type PostViewExportError = PostViewExportErrors[keyof PostViewExportErrors];

export type PostViewExportResponses = {
    /**
     * Export successful
     */
    200: ExportViewResponse;
};

export type PostViewExportResponse = PostViewExportResponses[keyof PostViewExportResponses];

export type PostViewDuplicateData = {
    body?: {
        /**
         * Name for the duplicated view (default adds "(Copy)" suffix)
         */
        name?: string;
    };
    path: {
        /**
         * Source view ID
         */
        viewId: string;
    };
    query?: never;
    url: '/views/{viewId}/duplicate';
};

export type PostViewDuplicateErrors = {
    /**
     * View not found
     */
    404: ErrorResponse;
    /**
     * Duplicate failed
     */
    500: ErrorResponse;
};

export type PostViewDuplicateError = PostViewDuplicateErrors[keyof PostViewDuplicateErrors];

export type PostViewDuplicateResponses = {
    /**
     * View duplicated
     */
    200: {
        success?: boolean;
        sourceViewId?: string;
        newViewId?: string;
        newViewName?: string;
    };
};

export type PostViewDuplicateResponse = PostViewDuplicateResponses[keyof PostViewDuplicateResponses];

export type PutViewRouterData = {
    body: {
        routerType: 'bendpoint' | 'manhattan';
    };
    path: {
        /**
         * View ID
         */
        viewId: string;
    };
    query?: never;
    url: '/views/{viewId}/router';
};

export type PutViewRouterErrors = {
    /**
     * Invalid router type
     */
    400: ErrorResponse;
    /**
     * View not found
     */
    404: ErrorResponse;
};

export type PutViewRouterError = PutViewRouterErrors[keyof PutViewRouterErrors];

export type PutViewRouterResponses = {
    /**
     * Router set
     */
    200: {
        success?: boolean;
        viewId?: string;
        routerType?: string;
    };
};

export type PutViewRouterResponse = PutViewRouterResponses[keyof PutViewRouterResponses];

export type PostViewLayoutData = {
    body?: LayoutRequest;
    path: {
        /**
         * View ID
         */
        viewId: string;
    };
    query?: never;
    url: '/views/{viewId}/layout';
};

export type PostViewLayoutErrors = {
    /**
     * View not found
     */
    404: ErrorResponse;
    /**
     * Layout failed
     */
    500: ErrorResponse;
    /**
     * Layout module not available
     */
    501: ErrorResponse;
};

export type PostViewLayoutError = PostViewLayoutErrors[keyof PostViewLayoutErrors];

export type PostViewLayoutResponses = {
    /**
     * Layout applied
     */
    200: LayoutResponse;
};

export type PostViewLayoutResponse = PostViewLayoutResponses[keyof PostViewLayoutResponses];

export type GetViewValidateData = {
    body?: never;
    path: {
        /**
         * View ID to validate
         */
        viewId: string;
    };
    query?: never;
    url: '/views/{viewId}/validate';
};

export type GetViewValidateErrors = {
    /**
     * View not found
     */
    404: ErrorResponse;
    /**
     * Validation failed
     */
    500: ErrorResponse;
};

export type GetViewValidateError = GetViewValidateErrors[keyof GetViewValidateErrors];

export type GetViewValidateResponses = {
    /**
     * Validation result
     */
    200: ValidateViewResponse;
};

export type GetViewValidateResponse = GetViewValidateResponses[keyof GetViewValidateResponses];

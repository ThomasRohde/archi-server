import { Command } from 'commander';
import { existsSync, mkdirSync, readdirSync, writeFileSync } from 'fs';
import { join, resolve } from 'path';
import { isCommanderError } from '../utils/commander';
import { print, success, failure } from '../utils/output';

const ELEMENTS_TEMPLATE = {
  version: '1.0',
  description: 'Starter: create a minimal element set',
  changes: [
    {
      op: 'createElement',
      type: 'application-component',
      name: 'My Application',
      tempId: 'app-main',
    },
    {
      op: 'createElement',
      type: 'business-actor',
      name: 'Business User',
      tempId: 'actor-user',
    },
    {
      op: 'createRelationship',
      type: 'serving-relationship',
      sourceId: 'app-main',
      targetId: 'actor-user',
      tempId: 'rel-serves',
      name: 'Application serves user',
    },
  ],
};

const VIEW_TEMPLATE = {
  version: '1.0',
  description: 'Starter: create and populate a view',
  idFiles: ['01-elements.ids.json'],
  changes: [
    {
      op: 'createView',
      name: 'Application Overview',
      viewpoint: 'application_cooperation',
      tempId: 'view-overview',
    },
    {
      op: 'addToView',
      viewId: 'view-overview',
      elementId: 'app-main',
      x: 120,
      y: 120,
      width: 140,
      height: 55,
      tempId: 'vo-app-main',
    },
    {
      op: 'addToView',
      viewId: 'view-overview',
      elementId: 'actor-user',
      x: 420,
      y: 120,
      width: 140,
      height: 55,
      tempId: 'vo-actor-user',
    },
    {
      op: 'addConnectionToView',
      viewId: 'view-overview',
      relationshipId: 'rel-serves',
      sourceVisualId: 'vo-app-main',
      targetVisualId: 'vo-actor-user',
    },
  ],
};

const WORKFLOW_README = `# archicli Starter Workflow

This folder was generated by \`archicli init\`.

## Files

- \`01-elements.json\`: create starter elements and relationship
- \`02-view.json\`: create a view, add elements, add connection

## Apply Cycle (polling is default)

1. Verify server/model readiness:
\`archicli doctor\`
2. Validate producer template:
\`archicli verify 01-elements.json --semantic\`
3. Apply producer template:
\`archicli batch apply 01-elements.json\`
4. Validate and apply consumer template:
\`archicli verify 02-view.json --semantic\`
\`archicli batch apply 02-view.json --layout\`

## Common Tasks

- Create element: edit \`01-elements.json\` and add a \`createElement\` op.
- Create view: edit \`02-view.json\` and add a \`createView\` op.
- Export view(s): \`archicli view export --all --dir exports\`.
- Poll an operation manually: \`archicli ops status <operationId> --poll\`.
`;

interface InitTargetResolution {
  directory: string;
  warnings: string[];
  error?: string;
}

function nextAvailableStarterSubdir(parentDir: string): string | null {
  const base = 'starter-bom';
  for (let i = 0; i < 100; i++) {
    const suffix = i === 0 ? '' : `-${i + 1}`;
    const candidate = join(parentDir, `${base}${suffix}`);
    if (!existsSync(candidate)) {
      return candidate;
    }
    try {
      if (readdirSync(candidate).length === 0) {
        return candidate;
      }
    } catch {
      // A non-directory path blocks this candidate; try the next suffix.
      continue;
    }
  }
  return null;
}

function resolveTargetDirectory(dir: string, force: boolean): InitTargetResolution {
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
    return { directory: dir, warnings: [] };
  }

  const entries = readdirSync(dir);
  if (entries.length === 0 || force) {
    return { directory: dir, warnings: [] };
  }

  const fallbackDir = nextAvailableStarterSubdir(dir);
  if (!fallbackDir) {
    const suggested = join(dir, 'starter-bom');
    return {
      directory: dir,
      warnings: [],
      error:
        `Target directory is not empty: ${dir}. ` +
        `Re-run with --force or use this exact command: archicli init "${suggested}"`,
    };
  }

  mkdirSync(fallbackDir, { recursive: true });
  return {
    directory: fallbackDir,
    warnings: [
      `Target directory is not empty: ${dir}. Created starter files in ${fallbackDir}. ` +
        'Use --force to write directly into the non-empty target.',
    ],
  };
}

/**
 * Bootstrap a minimal BOM workflow in the current or target directory.
 */
export function initCommand(): Command {
  return new Command('init')
    .description(
      'Create starter BOM templates and a quick workflow README.\n\n' +
        'Designed for first-run onboarding in new, empty, or existing working directories.'
    )
    .argument('[dir]', 'target directory (default: current working directory)')
    .option('--force', 'allow writing into a non-empty target directory')
    .action(async (dir: string | undefined, options: { force?: boolean }, cmd: Command) => {
      try {
        const requestedDir = resolve(dir ?? process.cwd());
        const force = Boolean(options.force);

        const resolvedTarget = resolveTargetDirectory(requestedDir, force);
        if (resolvedTarget.error) {
          print(failure('INIT_DIR_NOT_EMPTY', resolvedTarget.error));
          cmd.error('', { exitCode: 1 });
          return;
        }
        const targetDir = resolvedTarget.directory;

        const files: Array<{ name: string; content: string }> = [
          { name: '01-elements.json', content: JSON.stringify(ELEMENTS_TEMPLATE, null, 2) + '\n' },
          { name: '02-view.json', content: JSON.stringify(VIEW_TEMPLATE, null, 2) + '\n' },
          { name: 'README.md', content: WORKFLOW_README },
        ];

        const createdFiles: string[] = [];
        for (const file of files) {
          const targetPath = join(targetDir, file.name);
          if (existsSync(targetPath) && !force) {
            print(
              failure(
                'INIT_FILE_EXISTS',
                `Refusing to overwrite existing file: ${targetPath}. Re-run with --force to overwrite.`
              )
            );
            cmd.error('', { exitCode: 1 });
            return;
          }
          writeFileSync(targetPath, file.content, 'utf-8');
          createdFiles.push(targetPath);
        }

        const output: Record<string, unknown> = {
          directory: targetDir,
          ...(targetDir !== requestedDir ? { requestedDirectory: requestedDir } : {}),
          files: createdFiles,
          nextSteps: [
            `cd ${targetDir}`,
            'archicli doctor',
            'archicli verify 01-elements.json --semantic',
            'archicli batch apply 01-elements.json',
            'archicli verify 02-view.json --semantic',
            'archicli batch apply 02-view.json --layout',
            'archicli view export --all --dir exports',
          ],
        };
        if (resolvedTarget.warnings.length > 0) {
          output['warnings'] = resolvedTarget.warnings;
        }

        print(
          success(output)
        );
      } catch (err) {
        if (isCommanderError(err)) throw err;
        print(failure('INIT_FAILED', String(err)));
        cmd.error('', { exitCode: 1 });
      }
    });
}

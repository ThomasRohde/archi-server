// This file is auto-generated by @hey-api/openapi-ts

import { client } from './client.gen.js';
import type { Client, Options as Options2, TDataShape } from './client/index.js';
import type { DeleteViewData, DeleteViewErrors, DeleteViewResponses, GetElementByIdData, GetElementByIdErrors, GetElementByIdResponses, GetFoldersData, GetFoldersErrors, GetFoldersResponses, GetHealthData, GetHealthResponses, GetModelDiagnosticsData, GetModelDiagnosticsErrors, GetModelDiagnosticsResponses, GetModelStatsData, GetModelStatsErrors, GetModelStatsResponses, GetOpsListData, GetOpsListErrors, GetOpsListResponses, GetOpsStatusData, GetOpsStatusErrors, GetOpsStatusResponses, GetTestData, GetTestResponses, GetViewByIdData, GetViewByIdErrors, GetViewByIdResponses, GetViewsData, GetViewsErrors, GetViewsResponses, GetViewValidateData, GetViewValidateErrors, GetViewValidateResponses, PostModelApplyData, PostModelApplyErrors, PostModelApplyResponses, PostModelPlanData, PostModelPlanErrors, PostModelPlanResponses, PostModelQueryData, PostModelQueryErrors, PostModelQueryResponses, PostModelSaveData, PostModelSaveErrors, PostModelSaveResponses, PostModelSearchData, PostModelSearchErrors, PostModelSearchResponses, PostScriptsRunData, PostScriptsRunErrors, PostScriptsRunResponses, PostShutdownData, PostShutdownResponses, PostViewDuplicateData, PostViewDuplicateErrors, PostViewDuplicateResponses, PostViewExportData, PostViewExportErrors, PostViewExportResponses, PostViewLayoutData, PostViewLayoutErrors, PostViewLayoutResponses, PostViewsData, PostViewsErrors, PostViewsResponses, PutViewRouterData, PutViewRouterErrors, PutViewRouterResponses } from './types.gen.js';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Server health check
 *
 * Returns detailed server health information including memory usage,
 * operation queue statistics, and model information.
 *
 */
export const getHealth = <ThrowOnError extends boolean = false>(options?: Options<GetHealthData, ThrowOnError>) => (options?.client ?? client).get<GetHealthResponses, unknown, ThrowOnError>({ url: '/health', ...options });

/**
 * UI thread test
 *
 * Tests that the handler is running on the SWT Display (UI) thread.
 * Returns thread information and model reference status.
 *
 */
export const getTest = <ThrowOnError extends boolean = false>(options?: Options<GetTestData, ThrowOnError>) => (options?.client ?? client).get<GetTestResponses, unknown, ThrowOnError>({ url: '/test', ...options });

/**
 * Trigger server shutdown
 *
 * Initiates graceful server shutdown. The server will wait for in-flight
 * operations to complete (up to configured timeout) before stopping.
 *
 */
export const postShutdown = <ThrowOnError extends boolean = false>(options?: Options<PostShutdownData, ThrowOnError>) => (options?.client ?? client).post<PostShutdownResponses, unknown, ThrowOnError>({ url: '/shutdown', ...options });

/**
 * Model diagnostics and orphan detection
 *
 * Runs diagnostics on the loaded model, including detection of orphan/ghost
 * objects. Ghost objects exist in the EMF model resource but are not contained
 * in any folder — typically caused by silent GEF command stack rollbacks.
 *
 * Returns the current snapshot summary alongside any orphan elements and
 * relationships found via EMF-level traversal.
 *
 */
export const getModelDiagnostics = <ThrowOnError extends boolean = false>(options?: Options<GetModelDiagnosticsData, ThrowOnError>) => (options?.client ?? client).get<GetModelDiagnosticsResponses, GetModelDiagnosticsErrors, ThrowOnError>({ url: '/model/diagnostics', ...options });

/**
 * Query model snapshot
 *
 * Returns a summary of the model and a sample of elements.
 * Optionally include relationship samples by passing `relationshipLimit`.
 * The snapshot is captured when the server starts and refreshed after mutations.
 *
 */
export const postModelQuery = <ThrowOnError extends boolean = false>(options?: Options<PostModelQueryData, ThrowOnError>) => (options?.client ?? client).post<PostModelQueryResponses, PostModelQueryErrors, ThrowOnError>({
    url: '/model/query',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Generate change plan
 *
 * Generates a change plan without mutating the model.
 * Use this to preview what changes would be made before applying them.
 *
 */
export const postModelPlan = <ThrowOnError extends boolean = false>(options: Options<PostModelPlanData, ThrowOnError>) => (options.client ?? client).post<PostModelPlanResponses, PostModelPlanErrors, ThrowOnError>({
    url: '/model/plan',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Search elements with filters
 *
 * Search for elements and relationships matching specified criteria.
 * Supports filtering by type, name pattern (regex), and property key/value.
 *
 */
export const postModelSearch = <ThrowOnError extends boolean = false>(options?: Options<PostModelSearchData, ThrowOnError>) => (options?.client ?? client).post<PostModelSearchResponses, PostModelSearchErrors, ThrowOnError>({
    url: '/model/search',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Get element details
 *
 * Returns detailed information about a single element including:
 * - Name, type, documentation
 * - All properties
 * - Related relationships (incoming and outgoing)
 * - Views containing the element
 *
 */
export const getElementById = <ThrowOnError extends boolean = false>(options: Options<GetElementByIdData, ThrowOnError>) => (options.client ?? client).get<GetElementByIdResponses, GetElementByIdErrors, ThrowOnError>({ url: '/model/element/{elementId}', ...options });

/**
 * Save model to disk
 *
 * Persists the current model state to its file on disk.
 * Use this after making changes to ensure they are saved.
 *
 * **Auto-save behavior**: If the model has never been saved and no path is provided,
 * the server will automatically generate a path based on the model name in
 * `~/Documents/archi-models/`. The response will include `autoGeneratedPath: true`.
 *
 * To specify a custom location, provide the `path` parameter.
 *
 */
export const postModelSave = <ThrowOnError extends boolean = false>(options?: Options<PostModelSaveData, ThrowOnError>) => (options?.client ?? client).post<PostModelSaveResponses, PostModelSaveErrors, ThrowOnError>({
    url: '/model/save',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Get model statistics with type breakdowns
 *
 * Returns detailed statistics about the model including counts of elements,
 * relationships, and views grouped by ArchiMate type.
 *
 * This endpoint uses the model snapshot for fast response times without
 * traversing the live model. The snapshot is refreshed after mutations.
 *
 */
export const getModelStats = <ThrowOnError extends boolean = false>(options?: Options<GetModelStatsData, ThrowOnError>) => (options?.client ?? client).get<GetModelStatsResponses, GetModelStatsErrors, ThrowOnError>({ url: '/model/stats', ...options });

/**
 * List all folders
 *
 * Returns the complete folder hierarchy of the model.
 * Includes folder type, element count, and subfolder count.
 *
 */
export const getFolders = <ThrowOnError extends boolean = false>(options?: Options<GetFoldersData, ThrowOnError>) => (options?.client ?? client).get<GetFoldersResponses, GetFoldersErrors, ThrowOnError>({ url: '/folders', ...options });

/**
 * Apply changes asynchronously
 *
 * Queues model changes for asynchronous processing. Returns immediately
 * with an operation ID that can be polled via `/ops/status`.
 *
 * All changes are executed on the SWT Display thread and are fully undoable.
 *
 * **Internal chunking**: Large batches are automatically split into smaller
 * GEF CompoundCommands (default: 100 sub-commands per chunk, ~20 relationship
 * creates). This prevents silent rollback by Eclipse's command stack on very
 * large compound commands. Each chunk becomes a separate undo entry.
 *
 * **Post-execution verification**: After execution, created objects are verified
 * to still exist in model folders. If a silent rollback is detected, the
 * operation reports an error instead of falsely returning success.
 *
 * **Recommended**: Keep batches under 20 operations when creating relationships,
 * or use `archicli batch apply` which handles chunking automatically and polls by default.
 *
 */
export const postModelApply = <ThrowOnError extends boolean = false>(options: Options<PostModelApplyData, ThrowOnError>) => (options.client ?? client).post<PostModelApplyResponses, PostModelApplyErrors, ThrowOnError>({
    url: '/model/apply',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Poll operation status
 *
 * Returns the current status of an async operation queued via `/model/apply`.
 *
 */
export const getOpsStatus = <ThrowOnError extends boolean = false>(options: Options<GetOpsStatusData, ThrowOnError>) => (options.client ?? client).get<GetOpsStatusResponses, GetOpsStatusErrors, ThrowOnError>({ url: '/ops/status', ...options });

/**
 * List recent operations
 *
 * Returns recent async operations queued via `/model/apply`, sorted by newest first.
 *
 */
export const getOpsList = <ThrowOnError extends boolean = false>(options?: Options<GetOpsListData, ThrowOnError>) => (options?.client ?? client).get<GetOpsListResponses, GetOpsListErrors, ThrowOnError>({ url: '/ops/list', ...options });

/**
 * Execute JArchi script code
 *
 * Executes arbitrary JArchi script code synchronously on the UI thread.
 *
 * Scripts can communicate results by mutating the pre-initialized `__scriptResult` object:
 * ```javascript
 * // Correct - mutate the existing object properties
 * __scriptResult.value = { name: "example", count: 42 };
 * __scriptResult.files.push("path/to/file.png");
 *
 * // WRONG - reassignment loses the reference
 * // __scriptResult = { value: "data" };  // This won't work!
 * ```
 *
 * **Available helpers:**
 * - `getModel()` - Returns the first loaded model, or null if none
 * - `findElements(type)` - Query elements (wraps $() for API use)
 * - `findViews(name)` - Query views by optional name pattern
 * - `findRelationships(type)` - Query relationships
 * - `__scriptsDir__` - Path to scripts directory for loading libs
 *
 * **Note:** The bare `$()` selector requires UI selection context and will fail via API.
 * Use `getModel()` or `$.model.getLoadedModels().get(0)` instead.
 *
 * **⚠️ IMPORTANT: Property Modification Limitation**
 *
 * JArchi proxy property setters (`element.name = "..."`, `element.documentation = "..."`,
 * `element.prop("key", "value")`) will **fail with NullPointerException** when executed
 * via this endpoint. This is because the internal `CommandHandler.compoundcommands` field
 * is private and cannot be initialized from the API server context.
 *
 * **For element modifications, use `/model/apply` with `updateElement` operation instead:**
 * ```json
 * POST /model/apply
 * {
 * "changes": [{
 * "op": "updateElement",
 * "id": "element-id",
 * "name": "New Name",
 * "documentation": "New docs",
 * "properties": { "key": "value" }
 * }]
 * }
 * ```
 *
 * Scripts executed via this endpoint are best suited for:
 * - **Read-only operations** (queries, exports, analysis)
 * - **File generation** (PNG/JPG export, JSON export)
 * - **Operations using `undoableCommands`** directly (advanced)
 *
 * **⚠️ BLOCKING RISK:** Scripts execute synchronously on the SWT UI thread.
 * An infinite loop or long-running computation will freeze the entire Archi application
 * and block all other API requests. There is no timeout or cancellation mechanism.
 * Keep scripts short and well-tested. Maximum code size is limited by the server's
 * request body size limit (default 1MB).
 *
 */
export const postScriptsRun = <ThrowOnError extends boolean = false>(options: Options<PostScriptsRunData, ThrowOnError>) => (options.client ?? client).post<PostScriptsRunResponses, PostScriptsRunErrors, ThrowOnError>({
    url: '/scripts/run',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all views
 *
 * Returns a list of all views in the model with metadata.
 * Includes ArchiMate views, sketch views, and canvas views.
 *
 */
export const getViews = <ThrowOnError extends boolean = false>(options?: Options<GetViewsData, ThrowOnError>) => (options?.client ?? client).get<GetViewsResponses, GetViewsErrors, ThrowOnError>({ url: '/views', ...options });

/**
 * Create new view
 *
 * Creates a new ArchiMate view in the model synchronously.
 * The operation is undoable via Ctrl+Z in Archi.
 *
 * The view is created empty - use `/model/apply` to add elements.
 *
 */
export const postViews = <ThrowOnError extends boolean = false>(options: Options<PostViewsData, ThrowOnError>) => (options.client ?? client).post<PostViewsResponses, PostViewsErrors, ThrowOnError>({
    url: '/views',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete view
 *
 * Deletes a view from the model.
 * This operation removes the view and all its visual objects.
 *
 */
export const deleteView = <ThrowOnError extends boolean = false>(options: Options<DeleteViewData, ThrowOnError>) => (options.client ?? client).delete<DeleteViewResponses, DeleteViewErrors, ThrowOnError>({ url: '/views/{viewId}', ...options });

/**
 * Get view details
 *
 * Returns detailed information about a specific view including
 * all visual elements and connections with their positions.
 *
 */
export const getViewById = <ThrowOnError extends boolean = false>(options: Options<GetViewByIdData, ThrowOnError>) => (options.client ?? client).get<GetViewByIdResponses, GetViewByIdErrors, ThrowOnError>({ url: '/views/{viewId}', ...options });

/**
 * Export view to file
 *
 * Exports a view to an image file (PNG or JPEG).
 * Returns the absolute file path for local filesystem access.
 *
 * If no `outputPath` is specified, a temporary file is created.
 *
 * **Format-specific options:**
 * - `scale`: Image scale factor (0.5 to 4)
 * - `margin`: Margin in pixels
 *
 */
export const postViewExport = <ThrowOnError extends boolean = false>(options: Options<PostViewExportData, ThrowOnError>) => (options.client ?? client).post<PostViewExportResponses, PostViewExportErrors, ThrowOnError>({
    url: '/views/{viewId}/export',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Duplicate view
 *
 * Creates a deep copy of a view with all its visual objects.
 * The new view is placed in the same folder as the original.
 *
 */
export const postViewDuplicate = <ThrowOnError extends boolean = false>(options: Options<PostViewDuplicateData, ThrowOnError>) => (options.client ?? client).post<PostViewDuplicateResponses, PostViewDuplicateErrors, ThrowOnError>({
    url: '/views/{viewId}/duplicate',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Set connection router type
 *
 * Sets the connection routing style for the view.
 * - `bendpoint`: Manual routing with user-defined bendpoints
 * - `manhattan`: Automatic orthogonal routing
 *
 */
export const putViewRouter = <ThrowOnError extends boolean = false>(options: Options<PutViewRouterData, ThrowOnError>) => (options.client ?? client).put<PutViewRouterResponses, PutViewRouterErrors, ThrowOnError>({
    url: '/views/{viewId}/router',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Apply automatic layout
 *
 * Applies automatic graph layout algorithm to arrange elements in the view.
 * Supports Dagre and Sugiyama-style layered algorithms with configurable options.
 * Unknown algorithms fall back to dagre.
 *
 */
export const postViewLayout = <ThrowOnError extends boolean = false>(options: Options<PostViewLayoutData, ThrowOnError>) => (options.client ?? client).post<PostViewLayoutResponses, PostViewLayoutErrors, ThrowOnError>({
    url: '/views/{viewId}/layout',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Validate view connection integrity
 *
 * Validates the integrity of connections in a view.
 *
 * Checks performed:
 * - **Orphaned connections**: Visual connections without underlying relationship references
 * - **Direction mismatches**: Visual connections where source/target don't match relationship direction
 *
 * Use this endpoint after populating views to verify connection integrity.
 *
 */
export const getViewValidate = <ThrowOnError extends boolean = false>(options: Options<GetViewValidateData, ThrowOnError>) => (options.client ?? client).get<GetViewValidateResponses, GetViewValidateErrors, ThrowOnError>({ url: '/views/{viewId}/validate', ...options });
